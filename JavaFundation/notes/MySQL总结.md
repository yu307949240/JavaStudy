# MySQL总结

##1.索引

常见的索引模型：**哈希表索引，有序数组，二分搜索树索引，b+树索引**

###1.1 主键索引和非主键索引

InnoDB使用的索引是b+树索引

![屏幕快照 2018-11-27 20.23.01](/Users/yuyouquan/Desktop/屏幕快照 2018-11-27 20.23.01.png)

索引类型分为主键索引和非主键索引。

**主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引；**

**非主键索引的叶子结点内容是主键结点的值，在InnoDB里，非主键索引也称之为二级索引。**

### 1.2 回表查询

（1）基于主键索引和普通索引的查询有什么区别？

* 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索ID这颗b+树即可

* 如果语句是 select * from T where k= 5，即普通索引查询方式，则需要先搜索 k 索引树，得到

  ID 的值为 500，再到 ID 索引树搜索一次。这个过程称**回表查询**

（2）如果一个表没有主键，那么非主键索引查询的时候过程是什么？

没有主键的时候InnoDB会建一个Rowid做主键

### 1.3 覆盖索引

**select ID from T where k between 3 and 5；**

如果是select主键的情况那么就不需要在**回表查询**，减少了树的搜索次数，显著提升了性能；

如果有一个高频繁的请求可以考虑用覆盖索引的场景。

### 1.4 最左前缀匹配原则

### 1.5 索引下推

select * from tuser where name like '张 %' and age=10 and ismale=1;

(name,age)是联合索引

在MySQL5.6之前，只能从ID3开始一个个回表查询；

在MySQL 5.6之后，引入了**索引下推**优化可以在索引遍历的过程中，对包含的字段优先判断，直接过滤掉不满足条件的数据，减少回表次数。

* 无索引下推查询过程：

![屏幕快照 2018-11-27 20.49.57](/Users/yuyouquan/Desktop/屏幕快照 2018-11-27 20.49.57.png)

* 索引下推执行过程：

![屏幕快照 2018-11-27 20.50.06](/Users/yuyouquan/Desktop/屏幕快照 2018-11-27 20.50.06.png)

### 1.6聚簇索引和非聚簇索引

和1.1中讲的主键索引和非主键索引类似，

​        InnoDB使用的是**聚簇索引**，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。

　　MyISM使用的是**非聚簇索引**，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。

![屏幕快照 2018-11-27 20.55.50](/Users/yuyouquan/Desktop/屏幕快照 2018-11-27 20.55.50.png)

### 1.7 索引失效的场景

（1）如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。**要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引；**

（2）对于组合索引，不是使用的第一部分，则不会使用索引（**最左前缀匹配**）；

（3）like查询以**%开头**；

（4）如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引；

（5）如果mysql估计使用全表扫描要比使用索引快,则不使用索引。

## 2.MySQL中的锁(表锁和行锁)

概述：

* 表级锁，开销小，加锁快，锁定力度大，发生锁冲突的概率最高，并发度最低。
* 行级锁，开销大，加锁慢，会出现死锁，锁的粒度最小，发生锁冲突的概率最低，并发度也最高。
* 页级锁，开销和加锁时间，以及锁定粒度介于表锁和行锁之间，并发度一般。

InnoDB锁问题：

InnoDB与MyISAM最大的不同有两个，一是支持事务，二是采用了行锁。

### 2.1 Mysql中的事务

事务满足ACID四大特性

### 2.2 InnoDB行锁模式和加锁方法

InnoDB实现了以下两种方式的行锁：

* 共享锁(s)：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
* 排他锁(x)：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。

* 意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。

* 意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

#### **InnoDB行锁模式兼容性列表**

| 当前锁模式/是否兼容/请求锁模式 | X    | IX   | S    | IS   |
| ------------------------------ | ---- | ---- | ---- | ---- |
| X                              | 冲突 | 冲突 | 冲突 | 冲突 |
| IX                             | 冲突 | 兼容 | 冲突 | 兼容 |
| S                              | 冲突 | 冲突 | 兼容 | 兼容 |
| IS                             | 冲突 | 兼容 | 兼容 | 兼容 |

​       如果一个事务请求的锁模式与当前的锁兼容，InnoDB就请求的锁授予该事务；反之，如果两者两者不兼容，该事务就要等待锁释放。

​       意向锁是InnoDB自动加的，不需要用户干预，对于update，delete，insert语句，InnoDB会自动给涉及的数据集加排他锁；对于普通的select语句，InnoDB不会加任何锁，事务也可以显示加共享锁或排他锁。

* 加共享锁：SELECT * FROM table_name WHERE ... **LOCK IN SHARE MODE**
* 加排他锁：SELECT * FROM table_name WHERE ... **FOR UPDATE**

### 2.3 InnoDB行锁实现方式

​       InnoDB行锁是通过索引上的索引项来实现的，这就意味着：**只有通过索引来检索数据，InnoDB才会使用行级锁，否则是否表锁！**

### 2.4 间隙锁(Next-Key锁)

​       当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制不是所谓的间隙锁（Next-Key锁）。

​      举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,...,100,101，下面的SQL：

```sql
SELECT * FROM emp WHERE empid > 100 FOR UPDATE
```

​        是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。

​        InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况。

​        很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。

对于**InnoDB**表，主要有以下几点

* （１）InnoDB的行销是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。

* （２）InnoDB间隙锁机制，以及InnoDB使用间隙锁的原因。
* （３）在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。
* （４）ＭySQL的恢复和复制对InnoDB锁机制和一致性读策略也有较大影响。
* （５）锁冲突甚至死锁很难完全避免。

​    

​    

​    