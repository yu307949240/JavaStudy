# MySQL总结

##1.索引

常见的索引模型：**哈希表索引，有序数组，二分搜索树索引，b+树索引**

###1.1 主键索引和非主键索引

InnoDB使用的索引是b+树索引

<div align="center"> <img src="https://github.com/yu307949240/JavaStudy/blob/master/pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%2020.23.01.png" width="400" "/> </div><br> 

索引类型分为主键索引和非主键索引。

**主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引；**

**非主键索引的叶子结点内容是主键结点的值，在InnoDB里，非主键索引也称之为二级索引。**

### 1.2 回表查询

（1）基于主键索引和普通索引的查询有什么区别？

* 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索ID这颗b+树即可

* 如果语句是 select * from T where k= 5，即普通索引查询方式，则需要先搜索 k 索引树，得到

  ID 的值为 500，再到 ID 索引树搜索一次。这个过程称**回表查询**

（2）如果一个表没有主键，那么非主键索引查询的时候过程是什么？

没有主键的时候InnoDB会建一个Rowid做主键

### 1.3 覆盖索引

**select ID from T where k between 3 and 5；**

如果是select主键的情况那么就不需要在**回表查询**，减少了树的搜索次数，显著提升了性能；

如果有一个高频繁的请求可以考虑用覆盖索引的场景。

### 1.4 最左前缀匹配原则

### 1.5 索引下推

select * from tuser where name like '张 %' and age=10 and ismale=1;

(name,age)是联合索引

在MySQL5.6之前，只能从ID3开始一个个回表查询；

在MySQL 5.6之后，引入了**索引下推**优化可以在索引遍历的过程中，对包含的字段优先判断，直接过滤掉不满足条件的数据，减少回表次数。

* 无索引下推查询过程：

<div align="center"> <img src="https://github.com/yu307949240/JavaStudy/blob/master/pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%2020.49.57%202.png" width="400" "/> </div><br> 

* 索引下推执行过程：

<div align="center"> <img src="https://github.com/yu307949240/JavaStudy/blob/master/pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%2020.50.06.png" width="400" "/> </div><br> 

### 1.6聚簇索引和非聚簇索引

和1.1中讲的主键索引和非主键索引类似，

​        InnoDB使用的是**聚簇索引**，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。

　　MyISM使用的是**非聚簇索引**，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。
  
  <div align="center"> <img src="https://github.com/yu307949240/JavaStudy/blob/master/pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-27%2020.55.50.png" width="400" "/> </div><br> 

### 1.7 索引失效的场景

（1）如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。**要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引；**

（2）对于组合索引，不是使用的第一部分，则不会使用索引（**最左前缀匹配**）；

（3）like查询以**%开头**；

（4）如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引；

（5）如果mysql估计使用全表扫描要比使用索引快,则不使用索引。

## 2.MySQL中的锁(表锁和行锁)

概述：

* 表级锁，开销小，加锁快，锁定力度大，发生锁冲突的概率最高，并发度最低。
* 行级锁，开销大，加锁慢，会出现死锁，锁的粒度最小，发生锁冲突的概率最低，并发度也最高。
* 页级锁，开销和加锁时间，以及锁定粒度介于表锁和行锁之间，并发度一般。

InnoDB锁问题：

InnoDB与MyISAM最大的不同有两个，一是支持事务，二是采用了行锁。

### 2.1 Mysql中的事务

事务满足ACID四大特性

### 2.2 InnoDB行锁模式和加锁方法

InnoDB实现了以下两种方式的行锁：

* 共享锁(s)：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
* 排他锁(x)：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。

* 意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。

* 意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

#### **InnoDB行锁模式兼容性列表**

| 当前锁模式/是否兼容/请求锁模式 | X    | IX   | S    | IS   |
| ------------------------------ | ---- | ---- | ---- | ---- |
| X                              | 冲突 | 冲突 | 冲突 | 冲突 |
| IX                             | 冲突 | 兼容 | 冲突 | 兼容 |
| S                              | 冲突 | 冲突 | 兼容 | 兼容 |
| IS                             | 冲突 | 兼容 | 兼容 | 兼容 |

​       如果一个事务请求的锁模式与当前的锁兼容，InnoDB就请求的锁授予该事务；反之，如果两者两者不兼容，该事务就要等待锁释放。

​       意向锁是InnoDB自动加的，不需要用户干预，对于update，delete，insert语句，InnoDB会自动给涉及的数据集加排他锁；对于普通的select语句，InnoDB不会加任何锁，事务也可以显示加共享锁或排他锁。

* 加共享锁：SELECT * FROM table_name WHERE ... **LOCK IN SHARE MODE**
* 加排他锁：SELECT * FROM table_name WHERE ... **FOR UPDATE**

### 2.3 InnoDB行锁实现方式

​       InnoDB行锁是通过索引上的索引项来实现的，这就意味着：**只有通过索引来检索数据，InnoDB才会使用行级锁，否则是否表锁！**

### 2.4 间隙锁(Next-Key锁)

​       当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制不是所谓的间隙锁（Next-Key锁）。

​      举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,...,100,101，下面的SQL：

```sql
SELECT * FROM emp WHERE empid > 100 FOR UPDATE
```

​        是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。

​        InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况。

​        很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。

对于**InnoDB**表，主要有以下几点

* （１）InnoDB的行销是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。

* （２）InnoDB间隙锁机制，以及InnoDB使用间隙锁的原因。
* （３）在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。
* （４）ＭySQL的恢复和复制对InnoDB锁机制和一致性读策略也有较大影响。
* （５）锁冲突甚至死锁很难完全避免。

​    
## 3.MySQL中的事务

​       提到事务肯定会想到事务到ACID，其中多个事务同时执行，就可能出脏读、不可重复读、幻读的问题。为了解决这些问题，就有了**事务隔离级别**的概念。事务隔离级别包括：读未提交(read-uncommitted)、读提交(read-committed)、可重复读(repeatable-read)、可串行化(serializable)。

![屏幕快照 2018-11-30 10.47.49](/Users/yuyouquan/Desktop/屏幕快照 2018-11-30 10.47.49.png)

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到；**<font color="#FF0000">V1、V2、V3值都是2</font>**
- 读提交是指，一个事务提交之后，它做的变更就能被别的事务看到；**<font color="#FF0000">V1是1、V2、V3是2</font>**
- 可重复读是，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的；**<font color="#FF0000">V1、V2是1，V3是2</font>**
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写冲突的时候，后访问的事务必须等待前一个事务执行完成，才能继续执行。图中事务B执行update的时候会被锁住，直到事务A提交之后才可以继续执行，所以从事务A的角度来来说，**<font color="#FF0000">V1、V2是1，V3是2</font>**

### 3.1 事务的配置和启动

- 查看当前事务隔离级别：**<font color="#FF0000">select @@tx_isolation;</font>**
- 设置事务的隔离级别：**<font color="#FF0000">set tx_isolation='repeatable-read';</font>**
- 开启一个事务：**<font color="#FF0000">start transaction;／begin</font>**
- 提交或回滚一个事务：**<font color="#FF0000">commit / rollback</font>**
- <font color="#FF0000">set autocommit=0;</font>**，该命令会把这个线程的**自动提交关掉。这样只要执行一个select语句，事务就启动，并不会自动提交，直到主动执行commit或rollback或断开连接。   
- 默认的<font color="#FF0000">set autocommit=1;</font>，可以使用**begin/start transaction**开启事务， 执行**<font color="#FF0000">commit work and chain;</font>**则提交事务并自动启动下一个事务。

​    

### 3.2 事务隔离的实现(可重复读的场景下)

![屏幕快照 2018-11-30 11.24.29](/Users/yuyouquan/Desktop/屏幕快照 2018-11-30 11.24.29.png)

**<font color="#FF0000">MVCC：</font>**

​         **当前值是4，但是查询这条记录的时候，不同时刻启动的事务会有不同的read-view，如图中看到，在视图A、B、C中记录的值分别是1、2、4，同一个记录在系统里会存在多个版本，这就是MVCC(多版本并发控制)。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。**

 **<font color="#FF0000">回滚日志总不能一直保留吧，什么时候删除呢？</font>**

在不需要的时候就会删除，也就是说，系统会判断，当没有事务需要用到回滚日志时，回滚日志会被删除。

 **<font color="#FF0000">使用长事务的弊病? 为什么使用长事务可能拖垮整个库?</font>**

长事务意味着系统里会保存很多老的视图，这些事务随时可能访问数据库中任何数据，所以在事务提交之前，数据库中可能用到的回滚记录都必须保留，长的事务有可能回滚段非常长，这就导致的大量的占用空间。除了存储空间，长事务还会占用锁资源，也可能拖垮整个库。

事务相关问题：

1. 事务的概念是什么?
2. mysql的事务隔离级别读未提交, 读已提交, 可重复读, 串行各是什么意思?
3. 读已提交, 可重复读是怎么通过视图构建实现的?
4. 可重复读的使用场景举例? 对账的时候应该很有用?
5. 事务隔离是怎么通过read-view(读视图)实现的?
6. 并发版本控制(MCVV)的概念是什么, 是怎么实现的?
7. 使用长事务的弊病? 为什么使用常事务可能拖垮整个库?
8. 事务的启动方式有哪几种? 
9. commit work and chain的语法是做什么用的? 
10. 怎么查询各个表中的长事务?
11. 如何避免长事务的出现?

### 3.3 MVCC底层实现

数据表中的一行记录，其实可能有多个版本 (row), 每个版本都有自己的事务row trx_id；

InnoDB利用“MVCC”，实现了秒级别创建快照的能力。

1.事务A开始前，系统里提交事务ID最大是99；

2.事务A、B、C的版本号分别是100、101、102

3.三个事务开始前，(1,1)这一行的数据row trx_id = 99；这样A、B、C三个事务的up_limit_id都是99。

![屏幕快照 2018-11-30 14.17.55](/Users/yuyouquan/Desktop/屏幕快照 2018-11-30 14.17.55.png)

![屏幕快照 2018-11-30 11.44.32](/Users/yuyouquan/Desktop/屏幕快照 2018-11-30 11.44.32.png)

![屏幕快照 2018-11-30 14.08.21](/Users/yuyouquan/Desktop/屏幕快照 2018-11-30 14.08.21.png)

这里Q1查询到的值为3，Q2查询到的值为1；

Q2读的流程：

- **找到(1,3)的时候，判断出row trx_id=101大于up_limit_id，要不起**
- **接着找到上一个历史版本，一看row trx_id=102，还是要不起**
- **在往前找，终于找到了(1，1)，它的row trx_id=90；是可承认的数据，所以返回1**

Q1读的流程：

- **更新的时候都是先读后写，而这个读，只能读取当前值，称“当前读”**

- **因此，在更新的时候，当前读取到的数据是 (1,2)，更新后生成了新版本的数据(1,3)，这个新版本的row trx_id是101**
- **在执行Q1语句的时候，一看自己的版本号是101，最新数据的版本号也是101，所以查到的值为3**
​    

​    
